## 1. Заповнення пропусків

### **а)**  
Вказівник - це змінна, що в якості значення містить **адресу** іншої змінної.

### **б)**  
Тільки три величини можуть бути використані для ініціалізації вказівника:  
**адреса змінної**, **0**, або **NULL**.

### **в)**  
Єдине ціле число, яке може бути присвоєне вказівнику - це **0**.



## 2. Чи є наступні твердження вірними?

### **a)**  
Операцію взяття адреси `&` можна застосовувати лише до констант, виразів і змінних, оголошених із модифікатором `register`.

**Невірно**  
Оператор `&` не можна застосовувати до констант, виразів і змінних з модифікатором `register`.  
Його можна застосовувати лише до змінних, які реально зберігаються в пам’яті.



### **б)**  
Вказівник на `void` може бути розіменований.

**Невірно**  
`void*` не має конкретного типу, тому компілятор не знає, скільки байтів потрібно зчитати.  
Перед розіменуванням такий вказівник необхідно привести до конкретного типу.



### **в)**  
Вказівники на різні типи даних не можуть бути присвоєні один одному без використання операції приведення типів.

**Вірно**  
Вказівники на різні типи даних мають різну інтерпретацію пам’яті, тому їх присвоєння можливе лише з конкретним приведенням типів.



## 3. Масиви та вказівники

Вважаємо, що тип `float` займає 4 байти, а початкова адреса масиву дорівнює `1002500`.

### **а)**  
Оголошено масив `numbers` типу `float` з 10 елементів із використанням символічної константи `SIZE = 10`.  
Елементам масиву присвоєні значення: `0.0, 1.1, 2.2, …, 9.9`.

```
constexpr int SIZE = 10;
float numbers[SIZE] = {0.0, 1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9};
```

### **б)**  
Оголошено вказівник `pPtr`, який посилається на тип `float`.

```
float *pPtr;
```

### **в)**  
Елементи масиву `numbers` виводяться з використанням нотації **ім’я масиву / індекс** (`numbers[i]`) у циклі `for`.  
Кожен елемент виводиться з точністю до одного знака після коми.

```
for (int i = 0; i < SIZE; i++) {
     printf("%.1f ", numbers[i]);
}
```

### **г)**  
Вказівнику `pPtr` присвоєно адресу початку масиву `numbers` двома способами:
```
pPtr = numbers;
```
```
pPtr = &numbers[0];
```

### **ґ)**  
Елементи масиву `numbers` виводяться з використанням схеми **вказівник / зміщення**:
```
*(pPtr + i)
```

### **д)**  
Елементи масиву `numbers` виводяться з використанням схеми **ім’я масиву / зміщення**:
```
*(numbers + i)
```

### **е)**  
Елементи масиву `numbers` виводяться з використанням **індексації вказівника**:
```
pPtr[i]
```

### **є)**  
Звернення до четвертого елемента масиву (індекс `3`) можливе такими способами:
```
numbers[3]
```
```
*(numbers + 3)
```
```
pPtr[3]
```
```
*(pPtr + 3)
```
```
3[pPtr]
```
```
*(3 + pPtr)
```

### **ж)**  
Якщо `pPtr` вказує на початок масиву `numbers`, то вираз `pPtr + 8` посилається на адресу:  

`1002500 + 8 × 4 = 1002532`

За цією адресою знаходиться значення `numbers[8]`, тобто `8.8`.

### **з)**  
Якщо `pPtr` посилається на `numbers[5]`, то вираз `pPtr - 4` посилається на адресу:  

`1002520 - 4 × 4 = 1002504`

За цією адресою знаходиться значення `numbers[1]`, тобто `1.1`.



## 4. Операції з вказівниками

Вважаємо, що оголошено змінні `float number1 = 7.3;` та `float number2;`

### **а)**

Оголошено вказівник `fPtr`, який посилається на тип `float`
```
float *fPtr;
```

### **б)**

Вказівнику fPtr присвоєно адресу змінної number1.
```
fPtr = &number1;
```

### **в)**

Виведено значення величини, на яку посилається` fPtr`
```
printf("%f\n", *fPtr);
```

### **г)**

Змінній `number2` присвоєно значення величини, на яку вказує `fPtr`
```
number2 = *fPtr;
```

### **ґ)**

Виведено значення змінної `number2`
```
printf("%f\n", number2);
```

### **д)**

Виведено адресу змінної `number1` із використанням `%p`
```
printf("%p\n", &number1);
```

### **e)**
Виведена адреса співпадає з адресою змінної number1, оскільки fPtr зберігає її адресу.



## 5. Пошук помилок у фрагментах програм

Вважаємо, що оголошено:
```
int *zPtr;        /* zPtr посилається на масив z */
int *aPtr = NULL;
void *sPtr = NULL;
int number, i;
int z[5] = {1, 2, 3, 4, 5};

sPtr = z;
```

### а)

`++zPtr`

zPtr не ініціалізований (не містить адресу масиву z).
Спроба змінити випадкову адресу призведе до непередбачуваної поведінки програми.

Правильно:
```
zPtr = z;
++zPtr;
```

### б)

`number = zPtr;`

zPtr — це адреса (int*), а number — це int.
Ми намагаємось присвоїти адресу звичайній змінній.

Правильно:
```
number = *zPtr;
```
(щоб отримати значенн першого елемента масиву)

### в)

`number = *zPtr[2];`

Пріоритет операторів. zPtr[2] означає третій елемент масиву, а *zPtr[2] — це спроба розіменувати значення типу int, що неправильно.

Правильно: 
```
number = *(zPtr + 2);
```

або:
```
number = zPtr[2];
```

### г)

`++z;`

Ім’я масиву z — це константний вказівник на перший елемент. Його не можна змінювати.



Це все =)
