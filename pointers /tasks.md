## 1.Заповнення пропусків

### **а)**  
Вказівник - це змінна, що в якості значення містить **адресу** іншої змінної.

### **б)**  
Тільки три величини можуть бути використані для ініціалізації вказівника:  
**адреса змінної**, **0**, або **NULL**.

### **в)**  
Єдине ціле число, яке може бути присвоєне вказівнику - це **0**.



## 2.Чи є наступні твердження вірними?

### **a)**  
Операцію взяття адреси `&` можна застосовувати лише до констант, виразів і змінних, оголошених із модифікатором `register`.

**Невірно**  
Оператор `&` не можна застосовувати до констант, виразів і змінних з модифікатором `register`.  
Його можна застосовувати лише до змінних, які реально зберігаються в пам’яті.



### **б)**  
Вказівник на `void` може бути розіменований.

**Невірно**  
`void*` не має конкретного типу, тому компілятор не знає, скільки байтів потрібно зчитати.  
Перед розіменуванням такий вказівник необхідно привести до конкретного типу.



### **в)**  
Вказівники на різні типи даних не можуть бути присвоєні один одному без використання операції приведення типів.

**Вірно**  
Вказівники на різні типи даних мають різну інтерпретацію пам’яті, тому їх присвоєння можливе лише з конкретним приведенням типів.



## 3.Масиви та вказівники

Вважаємо, що тип `float` займає 4 байти, а початкова адреса масиву дорівнює `1002500`.

### **а)**  
Оголошено масив `numbers` типу `float` з 10 елементів із використанням символічної константи `SIZE = 10`.  
Елементам масиву присвоєні значення: `0.0, 1.1, 2.2, …, 9.9`.

```
constexpr int SIZE = 10;
float numbers[SIZE] = {0.0, 1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9};
```

### **б)**  
Оголошено вказівник `pPtr`, який посилається на тип `float`.

```
float *pPtr;
```

### **в)**  
Елементи масиву `numbers` виводяться з використанням нотації **ім’я масиву / індекс** (`numbers[i]`) у циклі `for`.  
Кожен елемент виводиться з точністю до одного знака після коми.

```
for (int i = 0; i < SIZE; i++) {
     printf("%.1f ", numbers[i]);
}
```

### **г)**  
Вказівнику `pPtr` присвоєно адресу початку масиву `numbers` двома способами:
```
pPtr = numbers;
```
```
pPtr = &numbers[0];
```

### **ґ)**  
Елементи масиву `numbers` виводяться з використанням схеми **вказівник / зміщення**:
```
*(pPtr + i)
```

### **д)**  
Елементи масиву `numbers` виводяться з використанням схеми **ім’я масиву / зміщення**:

`*(numbers + i)`

### **е)**  
Елементи масиву `numbers` виводяться з використанням **індексації вказівника**:
```
pPtr[i]
```

### **є)**  
Звернення до четвертого елемента масиву (індекс `3`) можливе такими способами:
```
numbers[3]
```
```
*(numbers + 3)
```
```
pPtr[3]
```
```
*(pPtr + 3)
```
```
3[pPtr]
```
```
*(3 + pPtr)
```

### **ж)**  
Якщо `pPtr` вказує на початок масиву `numbers`, то вираз `pPtr + 8` посилається на адресу:  

`1002500 + 8 × 4 = 1002532`

За цією адресою знаходиться значення `numbers[8]`, тобто `8.8`.

### **з)**  
Якщо `pPtr` посилається на `numbers[5]`, то вираз `pPtr - 4` посилається на адресу:  

`1002520 - 4 × 4 = 1002504`

За цією адресою знаходиться значення `numbers[1]`, тобто `1.1`.
